# RStan functions ---------------------------------------------------------

#' Stan test data
#'
#' @param n number of observations
#'
#' @return list of stan options
#' @export
#'
#' @examples
#' fake_data <- rstan_test_data(n=30)
rstan_test_data <- function(n=100){
    y <- sort(rnorm(n, 100, 15))
    x <- sort(sample(c(0,1), n, replace=TRUE))
    data <- list(y=y, x=x, n=n)
    pars <- c("Beta", "Sigma")
    inits <- function() list(Beta=c(88,24), Sigma=15)
    model <- "
data { 
int<lower=1> n; 
vector[n] y;
vector[n] x;
} 
parameters {
vector[2]     Beta;
real<lower=0> Sigma;
}
model {    
Sigma ~ cauchy(0, 3);
y ~ normal(Beta[1] + Beta[2] * x, Sigma);
}
"
return(list(data=data, pars=pars, inits=inits, model=model))
}

#' Stan Mejr
#' 
#' Wrapper function for simplifying \code{stan}. See \code{?rstan::stan} for more info.
#'
#' Also provides additional plots and repackages data into a single object
#' 
#' @param model model code or file name, both as character objects
#' @param name name of model being fitted
#' @param data data in stan format
#' @param pars named parameters. Defaults to kept parameters
#' @param samples list of sample parameters. See example for list structure.
#' @param init initial values
#' @param control control paramters for algorithm
#' @param out directory for where to save output files
#' @param parallel use multiple cores for running multiple chains
#' @param debug do a test run with options saved to global env
#' @param repackage add additional objects to the output of this function
#' @param ... other arguments from the main \code{rstan::stan} function
#'
#' @return list of objects: \code{stan_mcmc, pram, central, env, repack}
#' @export
#' @examples
#' # Using fake data for example
#' stan_dat <- rstan_test_data()
#' rstan_mejr(data=stan_dat$data,
#'            model=stan_dat$model,
#'            samples=list(n_chains = 4, n_final = 1200, n_thin = 2, n_warm = 800),
#'            pars=stan_dat$pars,
#'            init=stan_dat$init,
#'            out="~/Desktop",
#'            name="example_model",
#'            parallel=FALSE)
#' 
#' # Run default example model
#' rstan_debug <- rstan_mejr(debug=TRUE)
rstan_mejr <- function(model, name, data, pars, samples, init, control, out=NULL, parallel=FALSE, debug=FALSE, repackage=NULL, ...) {
    library(rstan)
    
    ## options list ------------------------------------------------------------
    stan_opts <- list()
    
    # check model name
    if (missing(name)) name <- "mejr_model"
    stan_opts[["model_name"]] <- name
    
    # check for missing output folder to contain all saved data
    if (is.null(out)) {
        diag_file <- NULL
    } else {
        diag_file <- file.path(out, paste0("diagnostic-", name))
    }
    
    stan_opts[["diagnostic_file"]] <- diag_file
    
    # check for missing control argument
    if (missing(control)) control <- NULL
    stan_opts[["control"]] <- control
    
    # check for samples argument
    if (missing(samples)) {
        samples <- list(n_chains = 4, n_final = 1200, n_thin = 2, n_warm = 800)
    }
    
    if (length(samples) < 4) {
        stop(simpleError("Make sure to specify the following options: n_chains, n_final, n_thin, n_warm"))
    }
    
    stan_opts[["chains"]] <- samples$n_chains
    stan_opts[["thin"]] <- samples$n_thin
    stan_opts[["warmup"]] <- samples$n_warm
    stan_opts[["iter"]] <- ceiling(samples$n_final*samples$n_thin / samples$n_chains + samples$n_warm)
    
    # no need for parallel if only one chain
    if (parallel & samples$n_chains == 1) {
        message("1 chain found: parallel was set to FALSE")
        parallel <- FALSE
    }
    
    if (parallel) {
        rstan::rstan_options(auto_write = TRUE)
        options(mc.cores = parallel::detectCores())
    } else {
        rstan::rstan_options(auto_write = FALSE)
        options(mc.cores = 1)
    }
    
    # check for missing initializations argument
    if (missing(init)) {
        init <- "random"
    }
    stan_opts[["init"]] <- init
    
    # Check for missing data argument
    if (missing(data)) {
        data <- rstan_test_data()$data
        warning(simpleWarning("No data suppled. Used example data."))
    } 
    stan_opts[["data"]] <- data
    
    # check for missing model parameters
    if (missing(pars)) {
        pars <- NA
    }
    stan_opts[["pars"]] <- pars
    
    # check for missing model file
    if (missing(model)) {
        warning(simpleWarning("No model supplied. Used example file."))
        model <- rstan_test_data()$model
    }
    nlines_model <- length(readLines(textConnection(model)))
    
    if (nlines_model > 1) {
        stan_opts[["model_code"]] <- model
    } else {
        stan_opts[["file"]] <- model
    }
    
    # combine arguments
    op <- list(...)
    toset <- !(names(stan_opts) %in% names(op))
    stan_opts <- c(stan_opts[toset], op)
    
    # set debug parameters and save opts to global
    if (debug) {
        stan_opts$chains=2
        stan_opts$thin=1
        stan_opts$warmup=25
        stan_opts$iter=50
        args <- c("stan_opts")
        for (i in args) {
            assign(bquote(.(i)), get(i, environment()), .GlobalEnv)
        }
    }
    
    ## start -------------------------------------------------------------------
    message("\n\nModel sampling initiated\n\n")
    startDate <- date()
    stan_fitted <- do.call(rstan::stan, stan_opts)
    
    ## print results -----------------------------------------------------------
    message("\n\nModel sampling finished...\n\n")
    
    if (!is.null(out)) {
        fout <- function(filename, ...) file.path(out, filename, ...)
        
        options(width=1000)
        sink(file=fout(paste0("results-", name, ".txt")), type="output")
        
        printSec("Runtime")
        print(startDate); cat("\n"); cat("\n"); print(date())
        
        printSec(paste("Stan Model:", name))
        print(stan_fitted, digits=4)
        
        sink()
        options(width=100)
        
        rstan_options(rstan_chain_cols=rainbow(samples$n_chains, alpha=1/samples$n_chains))
        
        pdf(file=fout(paste0("trace_nowarm-", name, ".pdf")), width=11, height=11)
        rstan::plot(stan_fitted, ask=FALSE)
        rstan::traceplot(stan_fitted, ask=FALSE, inc_warmup=FALSE)
        graphics.off()
        
        pdf(file=fout(paste0("trace_warm-", name, ".pdf")), width=11, height=11)
        rstan::plot(stan_fitted, ask=FALSE)
        rstan::traceplot(stan_fitted, ask=FALSE, inc_warmup=TRUE)
        graphics.off()
    }
    
    ## return object -----------------------------------------------------------
    
    stan_pram_keep <- rstan::extract(stan_fitted, permuted=TRUE)
    
    central <- pram_hist(stan_fitted, bndw=0.5, 
                         fname=fout(paste0("histograms-", name, ".pdf")), 
                         print_hist=ifelse(is.null(out), FALSE, TRUE))
    
    rstan_pack <- list(
        stan_mcmc=stan_fitted,
        pram=stan_pram_keep,
        central=central,
        env=stan_opts,
        repack=repackage
    )
    
    if (!is.null(out)) save(rstan_pack, file=fout(paste0("stan_obj-", name, ".Rdata")))
    
    return(rstan_pack)
}

#' Plot each chain and return the variances
#' 
#' This is to see which chains should be removed, if any.
#' 
#' Details soon.
#' 
#' @param chainlist A list of separate chains, if using \code{rstan_mejr} this is the \code{cl} list name.
#' @examples
#' rstan_pack <- rstan_mejr(parallel=TRUE)
#' view_stan_chains(rstan_pack$cl)
#' @export
view_stan_chains <- function(chainlist) {
    require(rstan)
    
    dat <- list()
    l <- length(chainlist)
    nc <- ceiling(sqrt(l))
    nr <- ceiling(l/nc)
    par(mfcol=c(nc, nr))
    
    for (i in 1:l) {
        s <- rstan::summary(chainlist[[i]])
        R_hat <- s$summary[, "Rhat"]
        nonNaN <- !is.nan(R_hat)
        r <- mean(R_hat[nonNaN], na.omit=TRUE)
        n <- mean(s$summary[nonNaN, "n_eff"])
        d <- extract(chainlist[[i]], "lp__")[[1]]
        dat[[i]] <- data.frame(chain=i, var=var(d), n_eff=n, Rhat=r)
        plot(d, type="l", main=paste("LP: chain", i))
        plot(density(d, bw=1), main=paste("LP: chain", i))
    }
    
    return(do.call(rbind, dat))
}

#' Point estimates and histogram plots of fitted parameters in Stan
#' 
#' Plots histograms, densities, and central tendency (defaults to median)
#' 
#' @param x rstan object
#' @param bndw adjust density line bandwidth
#' @param fname pdf file name for histograms
#' @examples
#' rstan_pack <- rstan_mejr()
#' stan_model <- rstan_pack$stan_mcmc
#' pram_hist(stan_model)
#' @export
pram_hist <- function(x, bndw=1.25, fname="plot_stanfit_hist.pdf", print_hist=TRUE) {
    #library(rstan)
    
    p <- rstan::extract(x, permuted=TRUE)
    
    pnames <- names(p)
    
    if (print_hist) {
        pdf(file=fname, width=8.5, height=11)
        par(mfcol=c(4,2))
    }
    
    central <- list()
    
    for (i in seq_len(length(p))) {
        # i <- 1
        temp_pram <- p[[i]] # temp_pram <- array(rnorm(100), c(5,5,4))
        d <- dim(temp_pram)
        dl <- length(d)
        brks <- ifelse(d[1] < 100, "Sturges", 100)
        
        if (dl==1) {
            
            # ii=2
            tp1 <- temp_pram
            y <- hdiq(tp1, warn=FALSE)$mid
            
            if (print_hist) {
                hist(tp1, main=paste0(pnames[i], "[", 1, "]"), xlab=NA, breaks=brks, freq=FALSE, border="gray60", col="gray60")
                lines(density(tp1, adjust=bndw), col="red", lwd=1)
                abline(v=y, col="green", lwd=2)
            }
            
        } else if (dl==2) {
            
            yl <- lapply(1:d[2], function(ii) {
                # ii=2
                tp2 <- temp_pram[,ii]
                mp <- hdiq(tp2, warn=FALSE)$mid
                
                if (print_hist) {
                    hist(tp2, main=paste0(pnames[i], "[", ii, "]"), xlab=NA, breaks=brks, freq=FALSE, border="gray60", col="gray60")
                    lines(density(tp2, adjust=0.25), col="red", lwd=1)
                    abline(v=mp, col="green", lwd=2)
                }
                
                return(mp)
            })
            
            y <- c(yl, recursive=TRUE)
            
        } else if (dl==3) {
            
            y <- array(0.0, c(d[2], d[3]))
            
            for (m in 1:d[2]) {
                for (n in 1:d[3]) {
                    
                    tp3 <- temp_pram[,m,n]
                    mp <- hdiq(tp3, warn=FALSE)$mid
                    y[m,n] <- mp
                    
                    if (print_hist) {
                        hist(tp3, main=paste0(pnames[i], "[", m, ",", n, "]"), xlab=NA, breaks=brks, freq=FALSE, border="gray60", col="gray60")
                        lines(density(tp3, adjust=0.25), col="red", lwd=1)
                        abline(v=mp, col="green", lwd=2)
                    }
                }
            }
            
        } else y <- NA
        
        central[[pnames[i]]] <- y
    }
    
    graphics.off()
    
    return(central)
}

#' WAIC and LOO fit statistics
#' 
#' Will find the WAIC and LOO stats if given a m x n matrix of log-likelihoods, where n= n obs and m= n samples
#' 
#' You must have estimated log_lik parameter or similarly named parameter in your model
#' 
#' @param log_lik A matrix of log-likelihoods, typically from a stan model
#' @examples
#' stan_fit_stat(extract(rstan_pack$stan_mcmc, "log_lik")$log_lik)
#' @export
stan_fit_stat <- function(log_lik){
    
    if (length(dim(log_lik))==1) {
        dim(log_lik) <- c(length(log_lik),1) 
    }  else {
        dim(log_lik) <- c(dim(log_lik)[1], prod(dim(log_lik)[2:length(dim(log_lik))]))
    }
    
    S <- nrow(log_lik)
    n <- ncol(log_lik)
    
    lpd <- log(colMeans(exp(log_lik)))
    p_waic <- apply(log_lik, 2, var)
    elpd_waic <- lpd - p_waic
    waic <- -2*elpd_waic
    
    loo_weights_raw <- 1/exp(log_lik-max(log_lik))
    loo_weights_normalized <- loo_weights_raw / matrix(colMeans(loo_weights_raw),nrow=S,ncol=n,byrow=TRUE)
    loo_weights_regularized <- pmin (loo_weights_normalized, sqrt(S))
    elpd_loo <- log(colMeans(exp(log_lik)*loo_weights_regularized) / colMeans(loo_weights_regularized))
    p_loo <- lpd - elpd_loo
    
    pointwise <- cbind(waic,lpd,p_waic,elpd_waic,p_loo,elpd_loo)
    total <- colSums(pointwise)
    se <- sqrt(n*apply(pointwise, 2, var))
    
    stat_summary <- data.frame(
        stat=total, 
        se, 
        description=c("Watanabe-Akaike information criterion on deviance scale", 
                      "log pointwise predictive density",
                      "WAIC effective number of parameters",
                      "expected log pointwise predictive density for a new dataset",
                      "LOO effective number of parameters",
                      "approximate leave-one-out cross-validation")
    )
    
    return(list(waic=total["waic"], elpd_waic=total["elpd_waic"],
                p_waic=total["p_waic"], elpd_loo=total["elpd_loo"], p_loo=total["p_loo"],
                pointwise=pointwise, summary=stat_summary))
}

#' Stan formatted Cholesky factored cov/cor matrix
#' 
#' @param cmat A covariance or correlation matrix
#' @examples
#' x <- rnorm(10)
#' y <- rnorm(10)
#' z <- rnorm(10)
#' 
#' X <- cbind(x,y,z)
#' 
#' cmat <- cor(X)
#' 
#' stan_chol(cmat)
#' @export
stan_chol <- function(cmat) {
    
    L <- chol(cmat)
    
    l <- dim(L)
    Lp <- array(0, l)
    for (M in l[1]:1) {
        for (N in l[2]:1) {
            Lp[M,N] <- L[N,M]
        }
    } 
    return(Lp)
}

